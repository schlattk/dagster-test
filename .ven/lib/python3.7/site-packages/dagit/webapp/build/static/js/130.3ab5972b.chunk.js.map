{"version":3,"file":"static/js/130.3ab5972b.chunk.js","mappings":"oKAAO,IAEMA,EAAY,SAACC,GACxB,MAHiC,WAG1BA,EAAEC,MAAMC,KAAR,UACAF,EAAEC,MAAMC,KADR,YACgBF,EAAEG,WAAWD,MAChCF,EAAEC,MAAMC,O,iIC0FRE,EAAY,GAIZC,EAAe,GAGfC,EAA4B,GAUlC,SAASC,EAAUC,GACjB,IAAMC,EAAmC,GAEzC,OADAD,EAAOE,SAAQ,SAACC,GAAD,OAAWA,EAAMD,SAAQ,SAACE,GAAD,OAAWH,GAAIV,EAAAA,EAAAA,GAAUa,IAASA,QACnEC,OAAOC,OAAOL,GAGhB,SAASM,EAAcC,EAA0BC,GACtD,IAAMC,EAAI,IAAIC,EAAAA,SAAAA,MAKVC,EAAkB,EAClBC,EApBc,IAqBdC,EArBc,IAsBdL,IAGFI,GADAC,EAAUC,MADVH,EAAkBI,KAAKC,IAAIR,EAASS,OAAOC,OAAQV,EAASW,QAAQD,QAAUvB,IAMhFc,EAAEW,SAAS,CAACC,QAAS,KAAMR,QAAAA,EAASD,QAAAA,IACpCH,EAAEa,qBAAoB,iBAAO,MAE7B,IAAMC,EAAwB,GACxBC,EAA4C,GAElDjB,EAAYN,SAAQ,SAACwB,GACnBD,EAAeC,EAAGhC,OAAQ,KAE5Bc,EAAYN,SAAQ,SAACwB,GAInB,IAAMC,EAASC,EAASF,EAAI,CAACG,EAAG,EAAGC,EAAG,IACtCpB,EAAEqB,QAAQL,EAAGhC,KAAM,CACjBsC,MAAOL,EAAOM,OAAOD,MACrBE,OAAQP,EAAOM,OAAOC,SAKxBR,EAAGR,OAAOhB,SAAQ,SAACiC,GACjBA,EAAMC,UAAUlC,SAAQ,SAACmC,GACnBZ,EAAeY,EAAI5C,MAAMC,OAAS+B,EAAeC,EAAGhC,QACtDgB,EAAE4B,QAAQ,CAACC,EAAGF,EAAI5C,MAAMC,KAAM8C,EAAGd,EAAGhC,MAAO,CAAC+C,OAAQ,IAEpDjB,EAAMkB,KAAK,CACTC,KAAM,CACJC,MAAO,CAACf,EAAG,EAAGC,EAAG,GACjBe,OAAQR,EAAI5C,MAAMC,KAClBoD,SAAUT,EAAI1C,WAAWD,MAE3BqD,GAAI,CACFH,MAAO,CAACf,EAAG,EAAGC,EAAG,GACjBe,OAAQnB,EAAGhC,KACXoD,SAAUX,EAAMxC,WAAWD,kBAQvCiB,EAAAA,OAAaD,GAEb,IAAMsC,EAAoC,GACpCC,EAA6C,GACnDvC,EAAEwC,QAAQhD,SAAQ,SAAU2C,GAC1B,IAAMM,EAAOzC,EAAEyC,KAAKN,GACfM,IAGLF,EAAWJ,GAAUM,MAMvB,IAAIC,EAAW,EACXC,EAAY,EAIhBhD,OAAOiD,KAAKL,GAAY/C,SAAQ,SAAC2C,GAC/B,IAAMM,EAAOF,EAAWJ,GAClBnB,EAAKlB,EAAY+C,MAAK,qBAAE7D,OAAmBmD,KACjD,GAAKnB,EAAL,CAIA,IAAMG,EAAIsB,EAAKtB,EAAIsB,EAAKnB,MAAQ,EAC1BF,EAAIqB,EAAKrB,EAAIqB,EAAKjB,OAAS,EACjCc,EAAIH,GAAUjB,EAASF,EAAI,CAACG,EAAAA,EAAGC,EAAAA,IAC/BsB,EAAWpC,KAAKC,IAAImC,EAAUvB,EAAIsB,EAAKnB,OACvCqB,EAAYrC,KAAKC,IAAIoC,EAAWvB,EAAIqB,EAAKjB,YAK3CxB,EAAEc,QAAQtB,SAAQ,SAAUsD,GAC1B,IAAMC,EAAOjC,EAAM+B,MAAK,SAACG,GAAD,OAAOA,EAAEf,KAAKE,SAAWW,EAAEjB,GAAKmB,EAAEX,GAAGF,SAAWW,EAAEhB,KACpEmB,EAASjD,EAAEkD,KAAKJ,GAAGG,OACrBF,IACFA,EAAKd,KAAKC,MAAQe,EAAO,GACzBF,EAAKV,GAAGH,MAAQe,EAAOA,EAAOxC,OAAS,OAI3C,IAAM0C,EAAwB,CAC5BrC,MAAAA,EACA0B,MAAOF,EACPhB,MAAOoB,EAAWtC,EAClBoB,OAAQmB,EAAYxC,EACpBiD,OAAQ,MASV,OANIrD,IAGFoD,EAAOC,OAMX,SAA6BnC,EAAuBD,EAAed,GACjE,IAAMiD,EAAyB,CAC7BE,sBAAuB,CACrBlC,EAAG,EACHC,EAAG,EACHE,MAAOL,EAAOK,MAAQ,EACtBE,OAAQP,EAAOO,OAAS,GAE1BD,OAAQ,CACNJ,EAAG/B,EACHgC,EAAGhC,EAA4Bc,EAC/BoB,MAAOL,EAAOK,MAAQlC,IACtBoC,OAAQP,EAAOO,OAAyD,GAA/CpC,EAA4Bc,IAEvDoD,gBAAiBlE,GACjBmE,mBAAoB,GACpB/C,OAAQ,GACRE,QAAS,GACTgB,UAAW8B,EACTnE,EAAU2B,EAAGR,OAAOjB,KAAI,SAACkE,GAAD,OAAOA,EAAE/B,eA3JH,GA6J9BT,EAAOK,OAEToC,WAAYF,EACVnE,EAAU2B,EAAGN,QAAQnB,KAAI,SAACkE,GAAD,OAAOA,EAAEC,eAClCzC,EAAOO,OAjKuB,GAkK9BP,EAAOK,QAILqC,EAAiBR,EAAO5B,OAAOH,EAAI+B,EAAO5B,OAAOC,OAgCvD,OA9BAR,EAAGR,OAAOhB,SAAQ,SAACiC,EAAOmC,GACxBT,EAAO3C,OAAOiB,EAAMxC,WAAWD,MAAQ,CACrCiC,OAAQ,CACNE,EAAGgC,EAAO5B,OAAOJ,EACjBC,EAAG+B,EAAO5B,OAAOH,EAAIwC,EAAM1E,EAAYA,EACvCoC,MAAO,EACPE,OAAQtC,GAEV2E,KAAM,CACJ1C,EAAGgC,EAAO5B,OAAOJ,EAAIhC,EACrBiC,EAAG+B,EAAO5B,OAAOH,EAAIwC,EAAM1E,EAAYA,QAK7C8B,EAAGN,QAAQlB,SAAQ,SAACsE,EAAQF,GAC1BT,EAAOzC,QAAQoD,EAAO7E,WAAWD,MAAQ,CACvCiC,OAAQ,CACNE,EAAGgC,EAAO5B,OAAOJ,EACjBC,EAAGuC,EAAiBC,EAAM1E,EAC1BoC,MAAO,EACPE,OAAQtC,GAEV2E,KAAM,CACJ1C,EAAGgC,EAAO5B,OAAOJ,EAAIhC,EACrBiC,EAAGuC,EAAiBC,EAAM1E,EAAYA,QAKrCiE,EApEWY,CAAoBZ,EAAQpD,EAAUG,IAGjDiD,EAoET,SAASK,EAA0BQ,EAAqB5C,EAAW6C,GAEjE,IACMC,EAAaD,EAAcE,IAC3BC,EAAU9D,KAAKC,IAAI,IAAK2D,EAAaF,EAAMvD,QAC3C4D,EAHQjF,GAGQkB,KAAKgE,IAAI,GAAIJ,EAAaF,EAAMvD,OAAS2D,GAAW,GACpEG,EAASH,EAAU,IAAM,GAAK,EAE9BjB,EAAqC,GAQ3C,OAPAa,EAAMxE,SAAQ,SAACgF,EAAMZ,GACnB,IAAMa,EAAiB,EAAKb,EAAM,EAAK,EACvCT,GAAOtE,EAAAA,EAAAA,GAAU2F,IAAS,CACxBrD,EAAGkD,EAAQT,EAAMQ,EACjBhD,EAAGA,EAAImD,EAASE,MAGbtB,EAGF,SAASjC,EAASF,EAAe0D,GAGtC,IAAIC,EAAOD,EAAKtD,EAEVwD,EAEF,GAEEC,EAAqB,SAACjB,EAAakB,GACvC,IAAMC,GAjPO,IAKK,GA4OmCD,GAAS,EACxD3D,EAAIuD,EAAKvD,EA7OG,GA6OiByC,EAAMmB,EACzC,MAAO,CACLlB,KAAM,CACJ1C,EAAGA,EAAIhC,EACPiC,EAAGuD,EA9OUzF,IAgPf+B,OAAQ,CACNE,EAAAA,EACAC,EAAGuD,EACHrD,MAtPc,GAuPdE,OAAQtC,KAKR8F,EAAgB,WACpB,IAAM/D,EAA0C,CAC9C4C,KAAM,CAAC1C,EAAGuD,EAAKvD,EAAIhC,EAAciC,EAAGuD,EA3PrBzF,IA4Pf+B,OAAQ,CACNE,EAAGuD,EAAKvD,EACRC,EAAGuD,EACHrD,MAAO,EACPE,OAAQtC,IAIZ,OADAyF,GAAQzF,EACD+B,GAGTD,EAAGR,OAAOhB,SAAQ,SAACiC,EAAOmC,GACxBgB,EAAcnD,EAAMxC,WAAWD,MAC7BgC,EAAGR,OAAOC,OA3Qc,EA4QpBoE,EAAmBjB,EAAK5C,EAAGR,OAAOC,QAClCuE,OAEJhE,EAAGR,OAAOC,OA/Qc,IAgR1BkE,GAAQzF,GAGV,IAAM+F,EAAoB,CACxB9D,EAAGuD,EAAKvD,EACRC,EAAGd,KAAKC,IAAImE,EAAKtD,EAAGuD,EAvRP,GAwRbrD,MA5Ra,IA6RbE,OAAQ0D,IAGVP,GA/RqB,GAiSjB3D,EAAG/B,WAAWkG,WAAW1E,QAAUO,EAAG/B,WAAWmG,cACnDH,EAASzD,QAjSgB,GAkSzBmD,GAlSyB,IAqS3B,IAAMU,EAKF,GAYJ,OAVArE,EAAGN,QAAQlB,SAAQ,SAACsE,EAAQF,GAC1ByB,EAAcvB,EAAO7E,WAAWD,MAC9BgC,EAAGN,QAAQD,OA1Sa,EA2SpBoE,EAAmBjB,EAAK5C,EAAGN,QAAQD,QACnCuE,OAEJhE,EAAGN,QAAQD,OA9Sa,IA+S1BkE,GAAQzF,GAGH,CACLqC,OAAQ,CACNJ,EAAGuD,EAAKvD,EAAI,EACZC,EAAGsD,EAAKtD,EAAI,EACZE,MAAOgE,IACP9D,OAAQmD,EAAOD,EAAKtD,EAAI,IAE1BJ,GAAIiE,EACJzE,OAAQoE,EACRlE,QAAS2E","sources":["../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts"],"sourcesContent":["export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\nimport {IBounds, IPoint} from './common';\n\ntype OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {\n    [inputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n  outputs: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], parentOp?: ILayoutOp): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.keys(dagreNodes).forEach((opName) => {\n    const node = dagreNodes[opName];\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn) {\n      conn.from.point = points[0];\n      conn.to.point = points[points.length - 1];\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for a solid with\n  // input blocks, then the main block, then output blocks (arranged vertically)\n  let accY = root.y;\n\n  const inputsLayouts: {\n    [inputName: string]: {layout: IBounds; port: IPoint};\n  } = {};\n\n  const buildIOSmallLayout = (idx: number, count: number) => {\n    const centeringOffsetX = (OP_WIDTH - IO_MINI_WIDTH * count) / 2;\n    const x = root.x + IO_MINI_WIDTH * idx + centeringOffsetX;\n    return {\n      port: {\n        x: x + PORT_INSET_X,\n        y: accY + PORT_INSET_Y,\n      },\n      layout: {\n        x,\n        y: accY,\n        width: IO_MINI_WIDTH,\n        height: IO_HEIGHT,\n      },\n    };\n  };\n\n  const buildIOLayout = () => {\n    const layout: {layout: IBounds; port: IPoint} = {\n      port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n      layout: {\n        x: root.x,\n        y: accY,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n    };\n    accY += IO_HEIGHT;\n    return layout;\n  };\n\n  op.inputs.forEach((input, idx) => {\n    inputsLayouts[input.definition.name] =\n      op.inputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.inputs.length)\n        : buildIOLayout();\n  });\n  if (op.inputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  } = {};\n\n  op.outputs.forEach((output, idx) => {\n    outputLayouts[output.definition.name] =\n      op.outputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.outputs.length)\n        : buildIOLayout();\n  });\n  if (op.outputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputsLayouts,\n    outputs: outputLayouts,\n  };\n}\n"],"names":["titleOfIO","i","solid","name","definition","IO_HEIGHT","PORT_INSET_X","PARENT_INVOCATION_PADDING","flattenIO","arrays","map","forEach","array","item","Object","values","layoutOpGraph","pipelineOps","parentOp","g","dagre","parentIOPadding","marginy","marginx","PARENT_DEFINITION_PADDING","Math","max","inputs","length","outputs","setGraph","rankdir","setDefaultEdgeLabel","edges","opNamesPresent","op","layout","layoutOp","x","y","setNode","width","bounds","height","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","opName","edgeName","to","ops","dagreNodes","nodes","node","maxWidth","maxHeight","keys","find","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","port","output","layoutParentGraphOp","links","layoutWidth","insetWidth","inset","spacing","baseX","min","yShift","link","shiftDirection","root","accY","inputsLayouts","buildIOSmallLayout","count","centeringOffsetX","buildIOLayout","opLayout","OP_BASE_HEIGHT","assetNodes","description","outputLayouts","OP_WIDTH"],"sourceRoot":""}